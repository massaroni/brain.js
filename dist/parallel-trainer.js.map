{"version":3,"sources":["../src/parallel-trainer.js"],"names":["trainParallel","unpackTrainOpts","workerFarm","require","workers","resolve","data","net","trainOptions","startMs","Date","now","log","console","logPeriod","parallel","NetCtor","Object","getPrototypeOf","constructor","maxEpochs","epochs","errorThresh","trainDefaults","threads","peerTrainOptions","assign","callback","train","iterations","globalWeights","toJSON","error","promises","thread","syncMode","result","runTrainingSync","type","partition","push","Promise","runTrainingWorker","results","all","worstError","trainedNets","threadCount","length","t","trained","status","partitionIdx","test","Math","max","avg","slice","fromJSON","endMs","elapsedMs","threadsOpts","Number","isInteger","netCtorName","name","threadsOptsObj","dataUsed","partitioned","types","totalThreads","netName","config","partitions","partitionSize","trainingDataSize","min","trainingData","unpartitioned","remainingData","splice","Error","shift","netType","netJSON","trainOpts","brainjs","default","ctor","reject","trainedNetJSON"],"mappings":"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","file":"parallel-trainer.js","sourcesContent":["import partition from './utilities/partition';\nconst workerFarm = require('worker-farm');\nconst workers    = workerFarm(require.resolve('./parallel-trainer-worker'));\n\n/**\n * Ensemble training, via simple parameter averaging.\n */\nexport async function trainParallel(data, net, trainOptions = {}) {\n  const startMs = Date.now();\n  const log = (trainOptions.log === true ? console.log : trainOptions.log) || (() => {});\n  const logPeriod = trainOptions.logPeriod || 1;\n  const parallel = trainOptions.parallel || {};\n  const NetCtor = Object.getPrototypeOf(net).constructor;\n  const maxEpochs = parallel.epochs || 1000;\n  const errorThresh = trainOptions.errorThresh || NetCtor.trainDefaults.errorThresh;\n  const threads = unpackTrainOpts(trainOptions, net, data);\n  \n  let peerTrainOptions = Object.assign({}, trainOptions);\n  delete peerTrainOptions.parallel;\n  delete peerTrainOptions.callback;\n  delete peerTrainOptions.log;\n  \n  net.train([data[0]], {errorThresh: 0.9, iterations: 1}); // initialize weights\n  let globalWeights = net.toJSON();\n\n  let error = 1;\n  let epochs = 0;\n  let iterations = 0;\n\n  while (epochs < maxEpochs && error >= errorThresh) {\n    let promises = [];\n\n    for (let thread of threads) {\n      if (parallel.syncMode === true) {\n        let result = runTrainingSync(thread.type, globalWeights, thread.partition, peerTrainOptions);\n        promises.push(Promise.resolve(result));\n      } else {\n        promises.push(runTrainingWorker(thread.type, globalWeights, thread.partition, peerTrainOptions));\n      }\n    }\n\n    const results = await Promise.all(promises);\n    let worstError = 0;\n    let trainedNets = [];\n    const threadCount = threads.length;\n    for (let t = threadCount - 1; t >= 0; t--) {\n      const trained = results[t].trained;\n      const status = results[t].status;\n      trainedNets.push(trained);\n      const partitionIdx = (t === 0 ? threadCount : t) - 1;\n      const result = trained.test(threads[partitionIdx].partition[0]);\n      worstError = Math.max(result.error, worstError);\n      iterations += status.iterations;\n    }\n    error = worstError;\n    epochs++;\n    if (epochs % logPeriod === 0) {\n      log('iterations: ' + iterations + ', error: ' + error + ', epochs: ' + epochs);\n    }\n\n    globalWeights = trainedNets[0].avg(...trainedNets.slice(1)).toJSON();\n  }\n\n  net.fromJSON(globalWeights);\n  const endMs = Date.now();\n  const elapsedMs = endMs - startMs;\n  return {error, iterations, epochs, elapsedMs};\n}\n\nexport function unpackTrainOpts(trainOptions, net, data) {\n  const parallel = trainOptions.parallel || {};\n  let threadsOpts = parallel.threads;\n  if (!threadsOpts || Number.isInteger(threadsOpts)) {\n    const netCtorName = Object.getPrototypeOf(net).constructor.name;\n    let threadsOptsObj = {};\n    threadsOptsObj[netCtorName] = threadsOpts || 1;\n    threadsOpts = threadsOptsObj;\n  }\n\n  let dataUsed = 0;\n  let partitioned = 0;\n  let types = [];\n  let totalThreads = 0;\n  for (let netName in threadsOpts) {\n    const config = threadsOpts[netName];\n    let threadCount = 1;\n    let partitions = null;\n    if (typeof config === \"object\") {\n      let partitionSize = config.partitionSize;\n      threadCount = config.threads || 1;\n      const trainingDataSize = Math.min(config.trainingDataSize || 0, data.length - dataUsed);\n\n      if (trainingDataSize) {\n        partitioned += threadCount;\n        let trainingData = data.slice(dataUsed, trainingDataSize);\n        partitions = partition(trainingData, threadCount, partitionSize);\n        dataUsed += trainingDataSize;\n      }\n    } else if (Number.isInteger(config)) {\n      threadCount = config || 1;\n    }\n    totalThreads += threadCount;\n\n    types.push({type: netName, threadCount, partitions});\n  }\n\n  const unpartitioned = totalThreads - partitioned;\n  if (unpartitioned) {\n    const remainingData = dataUsed === 0 ? data : data.slice(dataUsed);\n    const partitionSize = parallel.partitionSize || 1;\n    const partitions = partition(remainingData, unpartitioned, partitionSize);\n    for (let type of types) {\n      if (!type.partitions) {\n        type.partitions = partitions.splice(0, type.threadCount);\n      }\n    }\n    if (partitions.length > 0) {\n      throw new Error('Too many partitions');\n    }\n  }\n\n  let threads = [];\n  for (let type of types) {\n    let partitions = type.partitions;\n    for (let t = 0; t < type.threadCount; t++) {\n      threads.push({type: type.type, partition: partitions.shift()});\n    }\n  }\n\n  return threads;\n}\n\nfunction runTrainingSync(netType, netJSON, trainingData, trainOpts) {\n  const brainjs = require('./index').default;\n  const ctor = brainjs[netType];\n  const trained = new ctor();\n  trained.fromJSON(netJSON);\n  const status = trained.train(trainingData, trainOpts);\n  return {status, trained};\n}\n\nfunction runTrainingWorker(netType, netJSON, trainingData, trainOpts) {\n  const brainjs = require('./index').default;\n  return new Promise((resolve, reject) => {\n    workers({netType, netJSON, trainingData, trainOpts}, (error, results) => {\n      if (error) {\n        return reject(error);\n      }\n\n      const trained = new brainjs[netType]();\n      trained.fromJSON(results.trainedNetJSON);\n\n      resolve({trained, status: results.status});\n    });\n  });\n}\n"]}